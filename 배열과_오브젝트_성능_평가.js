// * 빅오 관점에서 오브젝트와 배열이 어떻게 작동하는지
// * 베열 앞에 요소를 추가하는 것이 왜 별로인지
// * 내장 메소드에 대해

// <객체>
// key & value를 가지고 있고 정렬되어있지 않은 데이터 구조
// 정렬할 필요가 없을 때 사용
// 빠른 접근, 입력과 제거를 원할 때
// 입력 O(1)
// 제거 O(1)
// 탐색 O(N)
// 접근 O(1)
// 객체에는 순서가 없어 입력할때 입력값이 들어갈 위치를 잡을 필요가 없다.
// 단지 key를 사용해 추가하기 때문에 빠르다.
// 고유의 key를 사용해 접근해서 접근과 제거가 빠르다.
// 값이 어디에 저장되어 있는지 탐색하는 시간은 느리다. 모든 값을 확인해야 하기 때문
// <객체의 메소드 성능>
// Object.keys => O(N)
// Object.values => O(N)
// Object.entries => O(N)
// 아이템 개수가 늘어나면 각 아이템에 접근해서 반환할 배열에 추가하는 시간이 늘어남
// Object.hasOwnProperty => O(1)
// key로 접근하기 때문에 아이템 개수에 영향을 받지 않음

// <배열>
// 정렬되어 있어 요소마다 인덱스를 가짐
// 정렬이 필요할 때 사용
// 입력과 제거를 할 때 성능이 떨어짐
// 입력
// 끝에 추가한다면 O(1)
// 앞에 추가한다면 O(N)
// 인덱스가 하나씩 밀리기 때문에 새로 배정해야 함
// 제거
// 끝 요소를 제거한다면 O(1)
// 첫 요소를 제거한다면 O(N)
// 인덱스 다시 배정
// 탐색 O(N)
// 배열이 길어질수록 탐색 시간은 길어짐
// 접근 O(1)
// 인덱스가 있어 접근을 할 때, 배열의 길이는 상관 없음
// <배열의 메소드 성능>
// Array.push => O(1)
// Array.pop => O(1)
// Array.shift => O(N)
// Array.unshift => O(N)
// Array.concat => O(N)
// Array.slice => O(N)
// Array.splice => O(N)
// Array.sort => O(N * log N)
// Array.forEach/map/filter/reduce... => O(N)
// 요소마다 작업을 해야 하기 때문에 배열의 길이가 늘어날수록 실행 시간도 늘어남

