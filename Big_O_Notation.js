// 빅오 표기법

// * 빅오 표기법의 필요성
// * 빅오 표기법?
// * 빅오 표기법을 간단히 표현하는 법
// * '시간 복잡성'과 '공간 복잡성'
// * 빅오 표기법을 사용해 알고리즘 평가
// * 로그(logarithm)?

// 한 알고리즘 문제에는 여러가지 해결법이 존재 => 가장 좋은 해결법은 무엇일까?
// 빅오 표기법은 여러가지 코드를 서로 비교하고 성능을 평가하는 방법
// 빅오 표기법은 코드를 '분류'할 수 있다.
// 좋은 코드 옆에 더 좋은 코드가 아닌 숫자로(정량적으로) 코드 성능을 표기할 수 있다.

// 예시
// 1부터 n까지(n포함) 정수를 모두 더한 함수
// 1번
function addUpToFirst(n) {
    let total = 0;
    for (let i = 1; i <= n; i++){
        total += 1;
    }
    return total;
}
// 2번
function addUpToSecond(n) {
    return n * (n + 1) / 2;
}

// 둘 중 더 나은 코드는 무엇일까?
// * 더 '나은' 코드란?
// 실행 속도(시간 복잡성)? 메모리 효율성(공간 복잡성)? 쉽게 읽을 수 있는 코드? 짧은 코드?

// * 시간 복잡성
// 코드의 실행 속도를 측정하려면? 타이머를 써볼까?
let timer1 = performance.now();
addUpToFirst(1000000000);
let timer2 = performance.now();
console.log(`${(timer2 - timer1) / 1000} 초 걸림`)

// 타이머 함수를 이용해 시간을 재는 것은 문제가 있다.(시간 측정의 정확성 문제)
// 기기 사양에 따라 두 함수의 실행 속도 차이가 달라질 수 있고 측정한 시간이 달라질 수 있다.
// 뿐만 아니라, 똑같은 기기에서 실행해도 매번 속도가 다르게 측정된다.
// 매우 빠른 함수들을 비교했을 땐 미세한 속도의 차이를 측정하기 더 힘들어진다.

// 그렇다면 별도의 타이머 코드를 쓰지 않고 코드를 평가하는 더 좋은 방법이 있지 않을까?
// 시간 대신 컴퓨터가 처리해야 하는 연산 개수를 카운트 (빅오는 연산 개수를 카운트한다.)
// 1번 함수는 for 반복을 실행해 반복문 내의 각각의 연산은 n번 반복
// n이 커질수록 연산의 개수도 비례해서 증가한다.
// 반면에 2번 함수는 n의 값과 상관없이 연산의 개수는 항상 3개(*, +, /)이다.

// 그래서 빅오 표기법은 무엇인가?
// 빅오 표기법은 입력 값이 커질수록 알고리즘 실행 시간이 어떻게 변하는지를 설명하는 공식적인 방법이다.
// 입력의 크기와 실행 시간의 관계를 전반적인 추세로 보는 것
// f(n) = n  => 선형 (n의 값이 커질수록 실행 시간도 비례해서 늘어남)
// f(n) = n^2 => 이차 (n의 값이 커지면 실행 시간은 n의 제곱)
// f(n) = 1 => 상수 (n의 값이 커져도 실행 시간은 영향받지 않음)
// 또는 완전히 다른 관계일 수 있다.

// 2번 함수의 경우 n의 값이 커져도 실행 시간은 영향받지 않는다.
// 이런 경우 빅오 표기법은 O(1)
// 1번 함수의 경우 n의 값이 커질수록 실행 시간도 늘어난다.
// 다시 말해, 연산의 개수는 n의 곱과 연결되어 있다.
// 빅오 표기법은 O(n)

// 다른 예시 O(n)
function countUpAndDown (n){
    console.log('카운트 시작')
    for (let i = 0; i < n; i++){ // O(n) n이 커질수록 루프가 실행되는 횟수 증가
        console.log(i);
    }
    console.log('다시 내려감')
    for (let j = n - 1; j >= 0; j--){ // O(n)이 2개여도 O(2n)이 아닌 O(n)
        console.log(j)
    }
    console.log('카운트 끝')
}

// 중첩 루프 예시 O(n^2)
function printAllPairs(n) {
    for (let i = 0; i < n; i++){ // O(n)
        for (let j = 0; j < n; j++){ // O(n) 연산 안에 O(n)이 중첩되어 있으면 O(n * n) = O(n^2)
            console.log(i, j)        // n이 커지면 실행 시간이 n의 제곱으로 증가
        }
    }
}

// * 빅오 표현식을 단순화 할 수 있는 규칙
// 빅오 표기법은 대략적으로 정확하게 큰 그림을 그리는 것
// 상수는 중요하지 않다.
// O(500) => O(1)
// O(2n) => O(n)
// O(3n^2) => O(n^2)
// 큰 그림의 그래프를 보면 추세선이 차이가 없으므로 0(1) > O(n) > O(n^2) 순으로 속도 비교하기
// 작은 연산자도 중요하지 않다.
// O(n + 10) => O(n)
// O(1000n + 50) => O(n)
// O(n^2 + 5n + 8) => O(n^2)

// 아래의 경우들을 처리하는 시간은 값의 크기에 따라 다르지 않고 일정하다.
// 1. 산술 연산
// 컴퓨터가 2+2를 처리하는 시간과 100만+2를 처리하는 시간은 큰 차이가 없다.
// 2. 변수 할당
// a = 20 과 a = 200만 의 처리 시간은 큰 차이가 없다.
// 3. 인덱스를 사용해서 배열 요소에 접근하는 것 또는 키를 이용해 객체의 데이터에 접근하는 것

// n이 커질수록 연산 개수에 영향을 줄 때 => O(n)
function logAtLeast5(n){
    for (let i = 1; i <= Math.max(5, n); i++){
        console.log(i)
    }
}

// n이 커져도 연산 개수에 영향이 없을 때 => O(1)
// n이 커져도 5번만 반복
function logAtMost5 (n){
    for (let i = 1; i <= Math.min(5, n); i++){
        console.log(i)
    }
}

// * (보조)공간 복잡성
// 보조 공간 : 입력된 값을 제외한 알고리즘 자체가 필요로 하는 공간
// booleans, numbers, undefined, null은 입력의 크기와 상관없이 모두 똑같은 공간 차지
// 문자열은 O(n) 공간 차지 (n = 문자열 길이)
// 참조 타입은 O(n) 공간 차지 (n = 배열의 길이 또는 객체의 키 개수)

// 예시
// O(1) => 입력의 크기와 상관없이 항상 차지하는 공간의 크기는 같다.
function sum (arr){
    let total = 0; // total = 0 => 1
    for (let i = 0; i < arr.length; i++){ // i = 0 => 2
        total += arr[i];
    }
    return total;
}
// O(n)
function double (arr){
    let newArr = [];
    for (let i = 0; i < arr.length; i++){
        newArr.push(2 * arr[i]);
    }
    return newArr;
}

// * 로그(logarithm)
// 로그 시간 복잡도
// 실행 시간이 빠른 순서
// O(1) > O(log n) > O(n) > O(nlog n) > O(n^2)
// 탐색 알고리즘, 효율적인 정렬 알고리즘은 로그 시간 복잡도와 관련이 있고
// 재귀는 로그 공간 복잡도와 관련이 있다.